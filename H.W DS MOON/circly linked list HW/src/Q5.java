public class Q5 {
   // {لحل هذه المشكلة وتقسيم القائمة المتصلة الدورية L إلى قائمتين متصلتين دوريتين بحجم نصف القائمة، يمكن اتباع الخوارزمية التالية:

       // 1. إذا كانت القائمة L فارغة، فقم بإرجاع قائمتين فارغتين.

       // 2. إذا كانت القائمة L تحتوي على عقدة واحدة فقط، فقم بإنشاء قائمتين فارغتين.

       // 3. إذا كانت القائمة L تحتوي على عقدتين، فقم بتحديد العقدة الأولى كعقدة في القائمة الأولى والعقدة الثانية كعقدة في القائمة الثانية
    // . قم بربط العقدة الأولى بالعقدة الثانية والعقدة الثانية بالعقدة الأولى لإنشاء قوائم متصلتين دوريتين بحجم نصف القائمة.

        //4. إذا كانت القائمة L تحتوي على أكثر من عقدتين، قم بتحديد نقطة الانقسام في القائمة. يمكن استخدام الحلقة الفورية
    // (Fast Runner / Slow Runner) لتحديد منتصف القائمة، حيث يتحرك العداء السريع بمعدل ضعف العداء البطيء.

       // - قم بتعيين عقدة slowRunner وعقدة fastRunner للعقدة الأولى في القائمة.
        //    - قم بتحريك slowRunner بمعدل عقدة واحدة في كل تكرار وقم بتحريك fastRunner بمعدل عقدتين في كل تكرار.
       // - استمر في التحرك حتى يصل fastRunner إلى نهاية القائمة (عندما يكون fastRunner.getNext() هو العقدة الأولى)، في هذه النقطة slowRunner سيكون في منتصف القائمة.

       // 5. قم بإنشاء القائمة الأولى والقائمة الثانية.

      //  - قم بتعيين العقدة الأولى في القائمة الأولى إلى العقدة الأولى في القائمة L.
       // - قم بتعيين العقدة الأولى في القائمة الثانية إلى slowRunner.getNext() (العقدة التي تلي slowRunner في القائمة L).
     // /  - قم بتعيين العقدة الأخيرة في القائمة الأولى إلى slowRunner.
      //  - قم بتعيين العقدة الأخيرة في القائمة الثانية إلى العقدة الأخيرة في القائمة L.
        //- قم بتوصيل العقدة الأخيرة في القائمة الأولى بالعقدة الأولى في القائمة الثانية والعكس.

       //6. قم بإرجاع القائمتين المتصلتين دوريتين بحجم نصف القائمة.

        //وهذا هو الخوارزمة بشكل مبسط:

    //java
        public Pair<CircularlyLinkedList<E>, CircularlyLinkedList<E>> splitList(CircularlyLinkedList<E> L) {
        // إذا كانت القائمة L فارغة، فقم بإرجاع قائمتين فارغتين
        if (L.isEmpty()) {
            return new Pair<>(new CircularlyLinkedList<>(), new CircularlyLinkedList<>());
        }

        Node slowRunner = L.getHead();
        Node fastRunner = L.getHead();

        // تحديد نقطة الانقسام في القائمة
        while (fastRunner.getNext() != L.getHead() && fastRunner.getNext().getNext() != L.getHead()) {
            slowRunner = slowRunner.getNext();
            fastRunner = fastRunner.getNext().getNext();
        }

        // إنشاء القائمة الأولى والقائمة الثانية
        CircularlyLinkedList<E> list1 = new CircularlyLinkedList<>();
        CircularlyLinkedList<E> list2 = new CircularlyLinkedList<>();

        list1.setHead(L.getHead());
        list1.setTail(slowRunner);

        list2.setHead(slowRunner.getNext());
        list2.setTail(L.getTail());

        // ربط القوائم المتصلة دوريًا
        list1.getTail().setNext(list2.getHead());
        list2.getTail().setNext(list1.getHead());

        return new Pair<>(list1, list2);
    }


        //باستخدام هذه الخوارزمية، يمكننا تقسيم القائمة المتصلة الدورية L إلى قائمتين متصلتين دوريتين بحجم نصف القائمة. يتم ذلك عن طريق تحديد نقطة الانقسام في القائمة باستخدام الحلقة الفورية، ثم إنشاء القائمتين الجديدتين وربطهما معًا بشكل دوري.
    }

}
